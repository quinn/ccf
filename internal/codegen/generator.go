package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// PageRoute represents a route generated from a page file
type PageRoute struct {
	Path         string
	TemplatePath string
	HandlerName  string
	Params       []string
}

// Generator handles the code generation for routes
type Generator struct {
	PagesDir    string
	OutputPath  string
	PackageName string
}

// New creates a new Generator instance
func New(pagesDir, outputPath, packageName string) *Generator {
	return &Generator{
		PagesDir:    pagesDir,
		OutputPath:  outputPath,
		PackageName: packageName,
	}
}

// Generate scans the pages directory and generates route code
func (g *Generator) Generate() error {
	routes, err := g.scanPagesDirectory()
	if err != nil {
		return fmt.Errorf("failed to scan pages directory: %w", err)
	}

	return g.generateRouterCode(routes)
}

// scanPagesDirectory walks through the pages directory and generates route information
func (g *Generator) scanPagesDirectory() ([]PageRoute, error) {
	var routes []PageRoute

	err := filepath.Walk(g.PagesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() || !strings.HasSuffix(info.Name(), ".templ") {
			return nil
		}

		// Get relative path from pages directory
		relPath, err := filepath.Rel(g.PagesDir, path)
		if err != nil {
			return fmt.Errorf("failed to get relative path: %w", err)
		}

		route, err := g.parseRouteFromFilename(relPath)
		if err != nil {
			return fmt.Errorf("failed to parse route from %s: %w", relPath, err)
		}

		routes = append(routes, route)
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to scan pages directory: %w", err)
	}

	return routes, nil
}

// parseRouteFromFilename converts a template filename into a route
func (g *Generator) parseRouteFromFilename(filename string) (PageRoute, error) {
	// Remove .templ suffix
	templatePath := strings.TrimSuffix(filename, ".templ")

	var params []string
	var routePath string
	var argName string
	var brackets bool
	var handlerName string

	// Parse the path and extract parameters
	for _, char := range templatePath {
		switch char {
		case '[':
			brackets = true
		case ']':
			brackets = false
			params = append(params, argName)
			routePath += ":" + argName
			argName = ""
		default:
			if brackets {
				argName += string(char)
			} else {
				routePath += string(char)
			}
		}
	}

	// Handle index routes
	if strings.HasSuffix(routePath, "index") {
		routePath = strings.TrimSuffix(routePath, "index")
		handlerName = "HandleIndex"
	} else if strings.Contains(routePath, "blog") {
		handlerName = "HandleBlogPost"
	}

	// Ensure path starts with /
	if !strings.HasPrefix(routePath, "/") {
		routePath = "/" + routePath
	}

	// Clean up any double slashes
	routePath = strings.ReplaceAll(routePath, "//", "/")

	// Trim trailing slash unless it's the root path
	if routePath != "/" && strings.HasSuffix(routePath, "/") {
		routePath = strings.TrimSuffix(routePath, "/")
	}

	return PageRoute{
		Path:         routePath,
		TemplatePath: filename,
		HandlerName:  handlerName,
		Params:       params,
	}, nil
}

// generateRouterCode generates the router implementation
func (g *Generator) generateRouterCode(routes []PageRoute) error {
	const routerTemplate = `// Code generated by go-astro. DO NOT EDIT.
package {{.PackageName}}

import (
	"github.com/labstack/echo/v4"
	"go.quinn.io/go-astro/pages"
)

// RegisterRoutes adds all page routes to the Echo instance
func RegisterRoutes(e *echo.Echo) {
	{{range .Routes}}
	e.GET("{{.Path}}", {{.HandlerName}}){{end}}
}

{{range .Routes}}
{{if eq .HandlerName "HandleIndex"}}
func HandleIndex(c echo.Context) error {
	return pages.Index().Render(c.Request().Context(), c.Response().Writer)
}
{{else if eq .HandlerName "HandleBlogPost"}}
func HandleBlogPost(c echo.Context) error {
	slug := c.Param("slug")
	return pages.BlogPost(slug).Render(c.Request().Context(), c.Response().Writer)
}
{{end}}
{{end}}
`

	tmpl, err := template.New("router").Parse(routerTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(filepath.Dir(g.OutputPath), 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	f, err := os.Create(g.OutputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	data := struct {
		PackageName string
		Routes      []PageRoute
	}{
		PackageName: g.PackageName,
		Routes:      routes,
	}

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
